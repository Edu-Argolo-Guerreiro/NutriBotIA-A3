"""
genetic_module.py
-----------------
Módulo de Algoritmo Genético para o projeto NutriBotIA.

Objetivo:
    Dado uma meta calórica, uma faixa de renda e restrições alimentares,
    gerar um cardápio (lista de alimentos) que:
        - fique próximo da meta calórica diária
        - respeite um custo máximo aproximado
        - evite alimentos que violem as restrições

Uso típico:
    from genetic_module import gerar_cardapio

    cardapio_df, melhor_individuo, fitness = gerar_cardapio(
        meta_kcal=1800,
        renda="baixa",  # "baixa", "media" ou "alta"
        restricoes_banidas=["lactose"]
    )
"""

import os
import random
from typing import List, Tuple, Optional

import numpy as np
import pandas as pd
from deap import base, creator, tools, algorithms

# =============================
# 1. Carregar base de alimentos
# =============================

# Detecta o caminho absoluto da pasta onde o script está
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
CAMINHO_ALIMENTOS = os.path.join(BASE_DIR, "alimentos_completo.csv")

# Carrega o arquivo CSV
if not os.path.exists(CAMINHO_ALIMENTOS):
    raise FileNotFoundError(f"Arquivo não encontrado: {CAMINHO_ALIMENTOS}")

ALIMENTOS = pd.read_csv(CAMINHO_ALIMENTOS)
N_ALIMENTOS = len(ALIMENTOS)
# Quantos itens o cardápio terá (ex.: 6 refeições/dia)
TAMANHO_CARDAPIO = 6

# =============================
# 2. Definição de tipos no DEAP
# =============================

# Evita erro se o módulo for importado mais de uma vez
if "FitnessMin" not in creator.__dict__:
    creator.create("FitnessMin", base.Fitness, weights=(-1.0,))  # queremos MINIMIZAR a penalidade

if "Individual" not in creator.__dict__:
    creator.create("Individual", list, fitness=creator.FitnessMin)

# =============================
# 3. Funções auxiliares
# =============================

def _mapear_renda_para_custo_max(renda: str) -> float:
    """
    Converte a categoria de renda em um custo máximo aproximado por dia.
    Isso é um valor totalmente ajustável, apenas um chute inicial.
    """
    renda = (renda or "").lower()
    if "baixa" in renda:
        return 25.0  # R$/dia
    elif "alta" in renda:
        return 60.0
    else:  # "media" ou qualquer outro
        return 40.0


def individuo_para_dataframe(individual: List[int]) -> pd.DataFrame:
    """
    Converte um indivíduo (lista de índices de alimentos) em um DataFrame
    apenas com as linhas correspondentes da base ALIMENTOS.
    """
    return ALIMENTOS.iloc[individual].reset_index(drop=True)


# =============================
# 4. Função de fitness
# =============================

def avaliar_cardapio(
    individual: List[int],
    meta_kcal: float,
    max_custo: float,
    restricoes_banidas: Optional[List[str]] = None,
) -> Tuple[float]:
    """
    Calcula a penalidade do cardápio representado pelo indivíduo.

    Quanto menor a penalidade, melhor o cardápio.

    Componentes da penalidade:
        - diferença relativa das calorias em relação à meta
        - extrapolação de custo em relação ao custo máximo
        - violação de restrições alimentares (penalidade alta)
    """
    if restricoes_banidas is None:
        restricoes_banidas = []

    df_cardapio = individuo_para_dataframe(individual)

    # Somatórios principais
    kcal_total = df_cardapio["kcal"].sum()
    custo_total = df_cardapio["custo_por_porcao"].sum()

    # Penalidade de calorias (quanto mais distante da meta, pior)
    if meta_kcal <= 0:
        pen_kcal = 1.0  # fallback
    else:
        pen_kcal = abs(kcal_total - meta_kcal) / meta_kcal  # valor entre 0 (perfeito) e...

    # Penalidade de custo (só se passar do max_custo)
    if max_custo <= 0:
        pen_custo = 0.0
    else:
        excedente = max(0.0, custo_total - max_custo)
        pen_custo = excedente / max_custo

    # Penalidade por violação de restrições
    pen_restricao = 0.0
    if restricoes_banidas:
        col_restr = df_cardapio.get("restricao")
        if col_restr is not None:
            for restr in col_restr:
                if str(restr).lower() in [r.lower() for r in restricoes_banidas]:
                    # Cada alimento "proibido" adiciona uma penalidade pesada
                    pen_restricao += 5.0

    # Penalidade total (pode ajustar pesos se quiser)
    penalidade_total = pen_kcal + pen_custo + pen_restricao

    return (penalidade_total,)


# =============================
# 5. Configuração do Algoritmo Genético
# =============================

def _criar_toolbox(
    meta_kcal: float,
    max_custo: float,
    restricoes_banidas: Optional[List[str]] = None,
    tamanho_cardapio: int = TAMANHO_CARDAPIO,
) -> base.Toolbox:
    """
    Cria e configura o toolbox do DEAP para o problema de cardápio.
    """
    toolbox = base.Toolbox()

    # Cada gene do indivíduo é um índice de alimento (0 .. N_ALIMENTOS-1)
    toolbox.register("attr_alimento", random.randrange, 0, N_ALIMENTOS)

    # Um indivíduo é uma lista de índices de tamanho 'tamanho_cardapio'
    toolbox.register(
        "individual",
        tools.initRepeat,
        creator.Individual,
        toolbox.attr_alimento,
        n=tamanho_cardapio,
    )

    # População é uma lista de indivíduos
    toolbox.register("population", tools.initRepeat, list, toolbox.individual)

    # Avaliação: amarra meta_kcal, custo e restrições na função de fitness
    toolbox.register(
        "evaluate",
        avaliar_cardapio,
        meta_kcal=meta_kcal,
        max_custo=max_custo,
        restricoes_banidas=restricoes_banidas,
    )

    # Operadores genéticos
    toolbox.register("mate", tools.cxTwoPoint)
    toolbox.register(
        "mutate",
        tools.mutUniformInt,
        low=0,
        up=N_ALIMENTOS - 1,
        indpb=0.2,  # probabilidade de mutar cada gene
    )
    toolbox.register("select", tools.selTournament, tournsize=3)

    return toolbox


# =============================
# 6. Função principal: gerar_cardapio
# =============================

def gerar_cardapio(
    meta_kcal: float,
    renda: str = "media",
    restricoes_banidas: Optional[List[str]] = None,
    tamanho_cardapio: int = TAMANHO_CARDAPIO,
    tamanho_pop: int = 40,
    n_geracoes: int = 30,
    cxpb: float = 0.7,  # probabilidade de crossover
    mutpb: float = 0.3,  # probabilidade de mutação
):
    """
    Executa o Algoritmo Genético e retorna:

        - cardapio_df: DataFrame com os alimentos selecionados
        - melhor_individuo: lista de índices dos alimentos
        - fitness: tupla de fitness (penalidade_total,)

    Parâmetros podem ser afinados depois para resultados melhores.
    """
    max_custo = _mapear_renda_para_custo_max(renda)

    toolbox = _criar_toolbox(
        meta_kcal=meta_kcal,
        max_custo=max_custo,
        restricoes_banidas=restricoes_banidas,
        tamanho_cardapio=tamanho_cardapio,
    )

    # Inicializar população
    pop = toolbox.population(n=tamanho_pop)

    # Estatísticas básicas (opcional)
    stats = tools.Statistics(lambda ind: ind.fitness.values[0])
    stats.register("avg", np.mean)
    stats.register("min", np.min)
    stats.register("max", np.max)

    # Rodar o AG (eaSimple faz tudo: seleção, cruzamento, mutação e evolução)
    pop, logbook = algorithms.eaSimple(
        population=pop,
        toolbox=toolbox,
        cxpb=cxpb,
        mutpb=mutpb,
        ngen=n_geracoes,
        stats=stats,
        verbose=False,  # pode colocar True para ver o progresso
    )

    # Selecionar o melhor indivíduo
    melhor_individuo = tools.selBest(pop, k=1)[0]
    fitness = melhor_individuo.fitness.values

    cardapio_df = individuo_para_dataframe(melhor_individuo)

    return cardapio_df, melhor_individuo, fitness


# =============================
# 7. Teste rápido (rodar direto)
# =============================

if __name__ == "__main__":
    # Exemplo de teste rápido local:
    cardapio, ind, fit = gerar_cardapio(
        meta_kcal=1800,
        renda="baixa",
        restricoes_banidas=["lactose"],
        tamanho_cardapio=6,
        tamanho_pop=30,
        n_geracoes=20,
    )

    print("[OK] Algoritmo Genético executado.")
    print("Melhor fitness (penalidade):", fit)
    print("\nCardápio sugerido:")
    print(cardapio[["nome", "kcal", "custo_por_porcao", "restricao"]])
